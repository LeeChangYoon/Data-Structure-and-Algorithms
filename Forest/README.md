# 4. 서로 다른 이진 트리의 개수

## 1. 포리스트 (Forest)

### 1. 포리스트의 개념

![image](https://user-images.githubusercontent.com/41320453/184079300-9ed9a7f9-7420-4d1b-bda3-0b85e2ffe219.png)
* 포리스트는 n개의 분리된 트리들의 집합이다.

![image](https://user-images.githubusercontent.com/41320453/184079323-914b5807-bc1c-4f5a-867b-2a811f6732eb.png)
* 포리스트를 트리로 변환하기 위해서는 각 트리를 이진 트리로 변환한 후, 그 트리들을 루트 노드들의 우측 자식으로 연결하면 된다.
* 또 다른 방법으로는 분리집합의 Union 연산을 통해 이진 트리로 변환해 주면 된다.
<br>

### 2. 포리스트의 순회
포리스트에 대응되는 이진트리의 전위, 중위 순회는 포리스트의 순회와 대응관계가 성립한다.

* 전위 순회
1. 포리스트의 첫 번째 트리의 루트 노드 방문
2. 첫 번째 트리의 서브트리들을 포리스트의 전위로 순회
3. 포리스트의 나머지 트리들을 포리스트의 전위로 순회

* 후위 순회
1. 포레스트의 첫 번째 트리의 서브트리들을 포리스트 중위로 순회
2. 첫 번째 트리의 루트 노드 방문
3. 나머지 트리들을 포리스트 중위로 순회
<br>

## 2. 분리 집합 (Disjoint Set)

### 1. 단순 분리 집합 연산

![image](https://user-images.githubusercontent.com/41320453/184080131-99c1cca9-ea23-4cee-b92f-d62f21a6cc43.png)

**부모 노드를 가리키는 배열로 집합을 표현하며, 각 집합의 루트 노드의 parent는 루토 노드의 인덱스이다.**

* SimpleFind(x): 해당 원소가 들어있는 집합의 루트 인덱스를 반환한다.
* SimpleUnion(i, j): 루트가 i와 j인 두 트리를 합친다 (j를 루트로 둔다).
* 해당 방법은 성능상 좋지 않다. **연산 수행 시 변질 트리가 생성되기 때문이다.**
<br>

### 2. Union(i, j) 연산에 가중 규칙 적용

* 루트 j의 노드들의 수가 루트 i의 노드들 수 보다 많다면 i의 parent를 j로 설정한다.
* 루트 i의 노드들의 수가 루트 j의 노드들 수 보다 많다면 j의 parent를 i로 설정한다.
* 둘 다 아니라면 i의 가중치를 1만큼 증가시키고, j의 parent를 i로 설정한다.
<br>

### 3. 붕괴 규칙을 통한 Find(x) 연산의 개선

![image](https://user-images.githubusercontent.com/41320453/184080946-5da7c046-4391-42b5-ad19-62b842569ecc.png)

* 만일 j가 i에서 루트로 가는 경로 상에 존재한다면, i의 부모가 i가 존재하는 집합의 루트가 아닌 경우 j의 부모를 그 집합의 루트로 설정한다.
* 개별 탐색 시간이 거의 2배로 증가하나 연속적 탐색에서의 최악의 경우 그 연산 시간을 줄일 수 있다.
